# What is Flagpole?

*"Let me run it up the flagpole first"*

Running something up the flagpole means you check on it first to see if it's good before going forward. And that's exactly what this framework is about, so we like the analogy. 

Flagpole is a flexible framework that can support a number of different types of testing:

* Full browser testing with Puppeteer
* Super-fast HTML DOM testing with Cheerio (jQuery for Node)
* REST API/JSON End Points
* Lightweight image tester that can verify the dimensions, mime and file size without downloading the whole thing
* Stylesheets including basic CSS validation
* Basic validation for other resources like JavaScript

Flagpole is designed to be simple so that the most junior engineer or QA analyst can pick it up within hours.

Flagpole is designed for portability, so that you can run it locally within your repository from a githook, in the cloud when something is deployed, as a scheduled job, or manually any time you want.

Flagpole has a rich CLI that can be used to list tests, run tests, create new suites or scenarios, etc.

# Getting Started

First thing we need to do is install Flagpole with npm. Go into the root of your project and run this:

```bash
npm i flagpole -g
npm i flagpole --save-dev
```

The above command installs it both locally (within the project) and globally. This is a little annoying that we have to do both. But we do. Globally is so that the command "flagpole" will run. The second one is so that your test suites can find it.

If you want to also use Puppeteer in your project install it as well, as a dev dependency.

```bash
npm i puppeteer --save-dev
```

You should be able to run the flagpole command now, which will give you instructions on how to use the CLI.

```bash
flagpole
```

Pretty colors, eh?

Now let's initialize our project

```bash
flagpole init
```

Once you answer those questions, you should have a flagpole.json file. Now we need to create our first test scenario.


```bash
flagpole add suite
```

Answer those questions and it will set up your first test file. Now let's make sure. If we run this command you should see it listed.

```bash
flagpole list
```

We should be able to run this very basic test with:

```bash
flagpole run
```

Sweet! How about we actually do something with the test now and run it. So open that test file that was generated by our "add suite" command earlier and add this into the next callback:

```typescript
this.assert('HTTP Status equals 200', response.status().equals(200);
```

Now run the flagpole run command again...

```bash
flagpole run
```

And if we did everything right, then you should see something like:

```text

 ================================================== 
                    HELLO WORLD                    
 ================================================== 
 » Base URL: http://www.flosports.tv 
 » Environment: dev 
 » Took 1383ms
 
 » Passed? Yes
 
 Just getting a test to run 
   ✔  Loaded HTML Page / 
   ✔  HTTP Status equals 200 
   »  Took 1382ms

```

Documentation is below, but also see the [examples folder in the repo](https://github.com/flocasts/flagpole/tree/master/example) and there will be blog posts coming up.

# Flagpole 2.0 CLI

## Commands

### about

Gives some information about Flagpole and its contributors.

```bash
flagpole about
```

### add env

Allows you to add a new environment. Environments are things like dev, staging, and prod. Each environment in a suite can have its own domain base, which allows you to use the same tests across environments easily.

```bash
flagpole add env
```

### add scenario

Adds a new scenario to a suite. If you have no suites set up yet, this will fail. If you have multiple suites, it will ask you which on you want to add the new scenario to.

This method will go into the suite file and add the code. Of course you can add this code manually, but this just gives you a template to start with.

```bash
flagpole add scenario
```

### add suite

Adds a new suite to the project. This will create the suite file and add in the base code. Of course you can add this all manually, but this just gives you a template to start with.

```bash
flagpole add suite
```

### deploy

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole deploy
```

### import suite

If you created or dropped some .js suite files into the tests folder without going through the CLI, this allows you to officially import them into the project.

```bash
flagpole import suite
```

### init

Initializes flagpole to set it up in the current project folder.

```bash
flagpole init
```

### list

Lists out all of the suites available in this project.

```bash
flagpole list
```

### login

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole login
```

### logout

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole logout
```

### pack

Puts your test suites and project files into a zip file so that they can be copied to something else.

```bash
flagpole pack
```

### rm env

Allows you to remove an environment from the project. This will remove it from the config, but will not modify your existing suite that reference it.

```bash
flagpole rm env
```

### rm suite

Allows you to remove a suite from the project. This will remove it from the config and delete the file

```bash
flagpole rm suite
```

### run

Runs your test suites. With no switches like this, it will run every one of the tests. See the -s switch about selecting which suite(s) specifically to run.

```bash
flagpole run
```

## Switches

### -c pathToConfig

By default Flagpole looks for flagpole.json file in the current folder as the project config. But you can use this switch to tell it to look elsewhere.

```bash
flagpole run -c /path/to/flagpole.json
```

### -e environmentName

Specifies the environment name, which will be the context that the tests execute with.

```bash
flagpole run -e staging
```

### -h

Hides the ASCII banner graphic.

```bash
flagpole run -h
```

### -l

There are some decorative florishes with the Flagpole output. Extra line breaks, horizontal rules, etc. They make it more readable. But perhaps you're trying to send the output to a log and you don't want that stuff. 

This "log" switch makes it only do the content lines and does one per line.

```bash
flagpole run -l
```

### -o outputType

Specifies that type of output you want Flagpole to create. The defualt is this pretty colored console ASCII text. But there are other options:

* browser - Formats it into HTML and opens it in your default web browser after
* console - Default
* csv - Comma separated
* html - Outputs HTML to the console
* json - JSON formatted 
* psv - Pipe separated
* text - Same as default but without the ASCII colors
* tsv - Tab separated

```bash
flagpole run -o browser
```

### -q 

Quiet mode. Silences all Flagpole command line output. This is useful when you don't want to capture what it has to say, you just want to know if it passed or failed. Which a script running this could get from the exit code of 0 or 1.

```bash
flagpole run -q
```

### -s suiteName

Specifies a certain suite or suites to run.

```bash
flagpole run -s smoke
```

You can list out multiple suite, space separated.

```bash
flagpole run -s smoke api e2e
```

### -v

Prints out simply what version of Flagpole CLI is installed.

```bash
flagpole -v
```


# Flagpole 2.0 Developer Docs

Here are the detailed documentation of the different methods you'll interact with in Flagpole.

[ under construction ]

## Assertions

Create an assertion within your scenario's "next" blocks like this:

```
this.assert(myValue)
```

You can also specify a message first, to override Flagpole's attempt at creating a default assertion method. That way it is really descriptive of what that assertion checks for.

```
this.assert('Make sure my value is a number', myValue)
```

This alone does nothing, since it just creates the assertion object with the value you want to assert against. But it hasn't actually asserted anything. So use one of the methods below.

### Methods

All methods return the Assertion itself, unless otherwise noted.

#### between

Works for numbers, but also casts strings to numbers for the compare. Tests if this value is between the minimum and maximum.

```
this.assert(myValue).between(0, 10);
```

#### contains

Tests whether the input value contains the argument. This works for strings, arrays, and even for objects. If it's an object, it checks if a property exists with that value.

```
this.assert('foobar').contains('foo');
```

#### endsWith

Tests whether the input value ends with the argument. Also works with arrays, testing whether the argument is the last value of the array.

```
this.assert('foobar').endsWith('bar');
```

#### equals

This be used with any types of values. It uses a rough (double equals) equality versus the exactly method that uses a precise (triple equals) equality.

```
this.assert(myValue).equals(5);
```

#### every

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that every one is true.

```
this.assert(['eminem', 'dre', 'ice cube']).every((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### exactly

This asserts an exact match with precise (triple equals) equality.

```
this.assert(myValue).exactly(5);
```

#### exists

Tests whether the input value is not null or undefined. This works well for selecting a DOM Element and then testing if it actually existed (since it returns null if not).

```
this.assert(await this.select('article')).exists();
```

#### greaterThan

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThan(5);
```

#### greaterThanOrEquals

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThanOrEquals(5);
```

#### in

Tests whether the input value is in the array of possible values.

```
this.assert('2pac').in(['2pac', 'biggie', 'daz']);
```

#### includes

Tests whether the input array includes the argument.

```
this.assert(['2pac', 'biggie', 'daz']).includes('2pac');
```

#### lessThan

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThan(5);
```

#### lessThanOrEquals

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThanOrEquals(5);
```

#### like

Like is a more fuzzy match. It ignores type differences and also trims whitespace and compares strings all lowercase. So it indicates the values are similar, but not necessarily equal.

```
this.assert(myValue).like('FooBar');
```

#### matches

Regular express compare of strings.

```
this.assert(myValue).matches(/^[a-z0-9]{3,32}$/i);
```

#### none

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that none are true.

```
this.assert(['2pac', 'biggie', 'daz']).none((rapper) => {
  return rapper == 'snoop';
})
```

#### rejects

Tests whether the input promise rejects.

```
await this.assert(myPromise).rejects();
```

#### resolves

Tests whether the input promise resolves.

```
await this.assert(myPromise).resolves();
```

#### some

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that at least one is true.

```
this.assert(['dre', 'snoop', '2pac']).some((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### startsWith

Tests whether the input value starts with the argument. Also works with arrays, testing whether the argument is the first value of the array.

```
this.assert(['foo', 'bar']).startsWith('foo');
```

### Properties

In addition to the methods to make the assertions, you can change them by chaining these properties.

#### length

This causes the assertion to evaluate the length of the input value, rather than the actual value. This works for anything that supports length including strings and arrays. For other things it will cast the input to a string and evaluate it.

```
this.assert('foobar').length.equals(6);
```

#### not

Flips the assertion to be the negative of itself.

```
this.assert(5).not.equals(6);
```

#### optional

This makes the assertion consider optional, meaning its failure won't cause the entire scenario to fail. If it passes, it will be listed as a pass. If it fails, it will be shown as failing in a special type of comment. That way you can see it, but not hold up the deploy because of it.

```
this.assert(5).optional.equals(6);
```

#### type

This causes the assertion to evaluate the type of the value, rather than the actual input value. The type will always be a lowercase string. It is a smart typeof that can tell things like 'promise' and 'regexp' that might otherewise evaluate to plain old object.

```
this.assert(5).type.equals('number');
```

## Suite

### Methods

#### after(callback: Function)

*returns Suite*

Hit this callback after all Scenarios finish executing.

`suite.after(() => { })`

#### afterEach(callback: Function)

*returns Suite*

Hit this callback after each Scenario finishes executing.

`suite.afterEach(() => { })`

#### base(parms: string | {})

*returns Suite*

Set the base URL that all Scenarios in this Suite will use as its starting point.

This can be just a string:

`suite.base('https://www.google.com/')`

Or it can be an object with environment as its key and the domain as its value.

```
suite.base({
  prod: 'https://www.google.com/',
  stag: 'http://www.google.internal/'
  dev: 'http://www.google.local/'
})
```

#### before(callback: Function)

*returns Suite*

Hit this callback before the first Scenario starts executing.

`suite.before(() => { })`

#### beforeEach(callback: Function)

*returns Suite*

Hit this callback before each Scenario starts executing.

`suite.beforeEach(() => { })`

#### browser(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the Browser request type. This will run a version of Chrominium with Puppeteer. 

`suite.browser('User Sign Up Work Flow', { headless: true, width: 1280, height: 800 })`

#### buildUrl(path: string)

*returns string*

Creates a fully qualified URL based on the input string. This will be relative to the Suite's base.

`suite.buildUrl('/index.html')`

#### catch(callback: Function)

*returns Suite*

Hit this callback after the Suite completes if there is an error or failure in any Scenario.

`suite.catch(() => { })`

#### execute()

*returns Suite*

If this string was told to wait() to execute, this will kick it off. This method will trigger the execute to then be called on each Scenario in the Suite.

`suite.execute()`

#### extjs(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the ExtJS request type. This will use Puppeteer just like the browser variety. The only difference is that it has Ext specific select methods and other helper methods to dig into this framework's custom internals.

`suite.extjs('User Sign Up Work Flow', { headless: true, width: 1280, height: 800 })`

#### failed()

*returns boolean*

Did this Suite (or any of its Scenarios) fail? If the Suite is not yet completed (or hasn't started yet) this will be false, unless any Scenario has already failed.

`suite.failed()`

#### finally(callback: Function)

*returns Suite*

Hit this callback after all Scenarios finish executing and after the Suite has been marked completed. This is the final step.

`suite.finally(() => { })`

#### html(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the HTML/DOM Only request type. This will use Cheerio to grab the HTML and load it into a jQuery-like DOM that we can test against. We can fake a browser here, allowing form completion, clicks, etc. However, it just is not a full browser so does not have JavaScript and won't work on SPAs, unless they have server side rendering as well.

`suite.html('Homepage Test')`

#### image(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the Image request type. This will use probe-image-size library to grab only the first few bytes of the image (not download the entire thing). This allows us to quickly test the basic properties.

`suite.image('Make sure image loads and is correct width')`

#### json(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the JSON/API End Point request type.

`suite.json('Articles API Test')`

#### next(callback: Function)

*returns Suite*

Hit this callback after all Scenarios finish executing, but before Suite has been marked as completed. There can be multiple nexts.

`suite.next(() => { })`

#### passed()

*returns boolean*

Did this Suite (and all of its Scenarios) complete and all were passing?

`suite.passed()`

#### print(exitAfterPrint: boolean = true)

*returns void*

Prints the results from the test execution to the console. This is often run inside the finally callback. If you leave the default argument as true, the process will terminate after it prints. So be sure to set that to false if you don't want it to do so.

`suite.finally(suite => suite.print(false))`

#### resource(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the Generic Resource request type. This is any other random type of file. You can test the file size, mime type, content, HTTP status, etc.

`suite.resource('Make sure this file loads')`

#### script(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the Script request type. It doesn't currently do anything more than load it. You can test the file size, mime type, HTTP Status, and such... so it may have some use but does not currently validate the JS.

`suite.script('Make sure JS file loads')`

#### subscribe(callback: Function)

Adds this callback to a PubSub subscription to get notified on any updates with the execute of thie Suite.

`suite.callback((suite: Suite, status: SuiteStatusEvent) => {  });`

#### success(callback: Function)

*returns Suite*

Hit this callback after all Scenarios finish executing if all Scenarios passed. This happens following after and next, but before finally.

`suite.success(() => { })`

#### verifySslCert(verify: boolean)

*returns this: Suite*

Tells the request not to worry about verifying any SSL certs for HTTPS requests. This is helpful for local environments that may not have a valid cert. This value is passed on to any Scenarios created in this Suite, so you don't have to set it each time.

`suite.verifySslCert(false)`

#### video(title: string, opts: any = {})

*returns Scenario*

Creates a new Scenario of the Video request type.

`suite.video('Make sure video loads')`

#### wait(verify: boolean = true)

*returns this: Suite*

Tells this suite not to execute right away. Will not execute any scenarios until .execute() is called. This wait value gets passed to any Scenarios created under this Suite, so that you don't have to set it each time.

`suite.wait()`

### Properties

#### baseUrl: string

The base URL tha tis being used to execute Scenarios in this Suite. It will come from the settings in the .base() method and what environment is selected.

#### executionDuration: number | null

The amount of time, in milliseconds, between when the first Scenario in the Suite started to execute and when the last one was completed.

#### title: string

The title of this suite, which is specified in the constructor.

#### totalDuration: number | null

The total amount of time, in milliseconds, between when the Suite was initialized and when it was completed.




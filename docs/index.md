# What is Flagpole?

*"Let me run it up the flagpole first"*

Running something up the flagpole means you check on it first to see if it's good before going forward. And that's exactly what this framework is about, so we like the analogy. 

Flagpole is a flexible framework that can support a number of different types of testing:

* Full browser testing with Puppeteer
* Super-fast HTML DOM testing with Cheerio (jQuery for Node)
* REST API/JSON End Points
* Lightweight image tester that can verify the dimensions, mime and file size without downloading the whole thing
* Stylesheets including basic CSS validation
* Basic validation for other resources like JavaScript

Flagpole is designed to be simple so that the most junior engineer or QA analyst can pick it up within hours.

Flagpole is designed for portability, so that you can run it locally within your repository from a githook, in the cloud when something is deployed, as a scheduled job, or manually any time you want.

Flagpole has a rich CLI that can be used to list tests, run tests, create new suites or scenarios, etc.

# Getting Started

First thing we need to do is install Flagpole with npm. Go into the root of your project and run this:

```bash
npm i flagpole -g
npm i flagpole --save-dev
```

The above command installs it both locally (within the project) and globally. This is a little annoying that we have to do both. But we do. Globally is so that the command "flagpole" will run. The second one is so that your test suites can find it.

If you want to also use Puppeteer in your project install it as well, as a dev dependency.

```bash
npm i puppeteer --save-dev
```

You should be able to run the flagpole command now, which will give you instructions on how to use the CLI.

```bash
flagpole
```

Pretty colors, eh?

Now let's initialize our project

```bash
flagpole init
```

Once you answer those questions, you should have a flagpole.json file. Now we need to create our first test scenario.


```bash
flagpole add suite
```

Answer those questions and it will set up your first test file. Now let's make sure. If we run this command you should see it listed.

```bash
flagpole list
```

We should be able to run this very basic test with:

```bash
flagpole run
```

Sweet! How about we actually do something with the test now and run it. So open that test file that was generated by our "add suite" command earlier and add this into the next callback:

```typescript
this.assert('HTTP Status equals 200', response.status().equals(200);
```

Now run the flagpole run command again...

```bash
flagpole run
```

And if we did everything right, then you should see something like:

```text

 ================================================== 
                    HELLO WORLD                    
 ================================================== 
 » Base URL: http://www.flosports.tv 
 » Environment: dev 
 » Took 1383ms
 
 » Passed? Yes
 
 Just getting a test to run 
   ✔  Loaded HTML Page / 
   ✔  HTTP Status equals 200 
   »  Took 1382ms

```

Documentation is below, but also see the [examples folder in the repo](https://github.com/flocasts/flagpole/tree/master/example) and there will be blog posts coming up.

# Flagpole 2.0 CLI

## Commands

### about

Gives some information about Flagpole and its contributors.

```bash
flagpole about
```

### add env

Allows you to add a new environment. Environments are things like dev, staging, and prod. Each environment in a suite can have its own domain base, which allows you to use the same tests across environments easily.

```bash
flagpole add env
```

### add scenario

Adds a new scenario to a suite. If you have no suites set up yet, this will fail. If you have multiple suites, it will ask you which on you want to add the new scenario to.

This method will go into the suite file and add the code. Of course you can add this code manually, but this just gives you a template to start with.

```bash
flagpole add scenario
```

### add suite

Adds a new suite to the project. This will create the suite file and add in the base code. Of course you can add this all manually, but this just gives you a template to start with.

```bash
flagpole add suite
```

### deploy

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole deploy
```

### import suite

If you created or dropped some .js suite files into the tests folder without going through the CLI, this allows you to officially import them into the project.

```bash
flagpole import suite
```

### init

Initializes flagpole to set it up in the current project folder.

```bash
flagpole init
```

### list

Lists out all of the suites available in this project.

```bash
flagpole list
```

### login

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole login
```

### logout

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole logout
```

### pack

Puts your test suites and project files into a zip file so that they can be copied to something else.

```bash
flagpole pack
```

### rm env

Allows you to remove an environment from the project. This will remove it from the config, but will not modify your existing suite that reference it.

```bash
flagpole rm env
```

### rm suite

Allows you to remove a suite from the project. This will remove it from the config and delete the file

```bash
flagpole rm suite
```

### run

Runs your test suites. With no switches like this, it will run every one of the tests. See the -s switch about selecting which suite(s) specifically to run.

```bash
flagpole run
```

## Switches

### -c pathToConfig

By default Flagpole looks for flagpole.json file in the current folder as the project config. But you can use this switch to tell it to look elsewhere.

```bash
flagpole run -c /path/to/flagpole.json
```

### -e environmentName

Specifies the environment name, which will be the context that the tests execute with.

```bash
flagpole run -e staging
```

### -h

Hides the ASCII banner graphic.

```bash
flagpole run -h
```

### -l

There are some decorative florishes with the Flagpole output. Extra line breaks, horizontal rules, etc. They make it more readable. But perhaps you're trying to send the output to a log and you don't want that stuff. 

This "log" switch makes it only do the content lines and does one per line.

```bash
flagpole run -l
```

### -o outputType

Specifies that type of output you want Flagpole to create. The defualt is this pretty colored console ASCII text. But there are other options:

* browser - Formats it into HTML and opens it in your default web browser after
* console - Default
* csv - Comma separated
* html - Outputs HTML to the console
* json - JSON formatted 
* psv - Pipe separated
* text - Same as default but without the ASCII colors
* tsv - Tab separated

```bash
flagpole run -o browser
```

### -q 

Quiet mode. Silences all Flagpole command line output. This is useful when you don't want to capture what it has to say, you just want to know if it passed or failed. Which a script running this could get from the exit code of 0 or 1.

```bash
flagpole run -q
```

### -s suiteName

Specifies a certain suite or suites to run.

```bash
flagpole run -s smoke
```

You can list out multiple suite, space separated.

```bash
flagpole run -s smoke api e2e
```

### -v

Prints out simply what version of Flagpole CLI is installed.

```bash
flagpole -v
```


# Flagpole 2.0 Developer Docs

Here are the detailed documentation of the different methods you'll interact with in Flagpole.

[ under construction ]

## Assertions

Create an assertion within your scenario's "next" blocks like this:

```
this.assert(myValue)
```

You can also specify a message first, to override Flagpole's attempt at creating a default assertion method. That way it is really descriptive of what that assertion checks for.

```
this.assert('Make sure my value is a number', myValue)
```

This alone does nothing, since it just creates the assertion object with the value you want to assert against. But it hasn't actually asserted anything. So use one of the methods below.

### Methods

All methods return the Assertion itself, unless otherwise noted.

#### between(min: number, max: number): Assertion

Works for numbers, but also casts strings to numbers for the compare. Tests if this value is between the minimum and maximum.

```
this.assert(myValue).between(0, 10);
```

#### contains(value: string): Assertion

Tests whether the input value contains the argument. This works for strings, arrays, and even for objects. If it's an object, it checks if a property exists with that value.

```
this.assert('foobar').contains('foo');
```

#### endsWith(value: string): Assertion

Tests whether the input value ends with the argument. Also works with arrays, testing whether the argument is the last value of the array.

```
this.assert('foobar').endsWith('bar');
```

#### equals(value: any): Assertion

This be used with any types of values. It uses a rough (double equals) equality versus the exactly method that uses a precise (triple equals) equality.

```
this.assert(myValue).equals(5);
```

#### every(callback: Function): Assertion

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that every one is true.

```
this.assert(['eminem', 'dre', 'ice cube']).every((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### exactly(value: any): Assertion

This asserts an exact match with precise (triple equals) equality.

```
this.assert(myValue).exactly(5);
```

#### exists(): Assertion

Tests whether the input value is not null or undefined. This works well for selecting a DOM Element and then testing if it actually existed (since it returns null if not).

```
this.assert(await this.select('article')).exists();
```

#### greaterThan(value: number): Assertion

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThan(5);
```

#### greaterThanOrEquals(value: number): Assertion

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThanOrEquals(5);
```

#### in(listOfValues: any[]): Assertion

Tests whether the input value is in the array of possible values.

```
this.assert('2pac').in(['2pac', 'biggie', 'daz']);
```

#### includes(value: any): Assertion

Tests whether the input array includes the argument.

```
this.assert(['2pac', 'biggie', 'daz']).includes('2pac');
```

#### lessThan(value: number): Assertion

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThan(5);
```

#### lessThanOrEquals(value: number): Assertion

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThanOrEquals(5);
```

#### like(value: string): Assertion

Like is a more fuzzy match. It ignores type differences and also trims whitespace and compares strings all lowercase. So it indicates the values are similar, but not necessarily equal.

```
this.assert(myValue).like('FooBar');
```

#### matches(pattern: RegExp | string): Assertion

Regular express compare of strings.

```
this.assert(myValue).matches(/^[a-z0-9]{3,32}$/i);
```

#### none(callback: Function): Assertion

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that none are true.

```
this.assert(['2pac', 'biggie', 'daz']).none((rapper) => {
  return rapper == 'snoop';
})
```

#### rejects(): Assertion

Tests whether the input promise rejects.

```
await this.assert(myPromise).rejects();
```

#### resolves(): Assertion

Tests whether the input promise resolves.

```
await this.assert(myPromise).resolves();
```

#### some(callback: Function): Assertion

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that at least one is true.

```
this.assert(['dre', 'snoop', '2pac']).some((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### startsWith(value: string): Assertion

Tests whether the input value starts with the argument. Also works with arrays, testing whether the argument is the first value of the array.

```
this.assert(['foo', 'bar']).startsWith('foo');
```

### Properties

In addition to the methods to make the assertions, you can change them by chaining these properties.

#### length: Assertion

This causes the assertion to evaluate the length of the input value, rather than the actual value. This works for anything that supports length including strings and arrays. For other things it will cast the input to a string and evaluate it.

```
this.assert('foobar').length.equals(6);
```

#### not: Assertion

Flips the assertion to be the negative of itself.

```
this.assert(5).not.equals(6);
```

#### optional: Assertion

This makes the assertion consider optional, meaning its failure won't cause the entire scenario to fail. If it passes, it will be listed as a pass. If it fails, it will be shown as failing in a special type of comment. That way you can see it, but not hold up the deploy because of it.

```
this.assert(5).optional.equals(6);
```

#### type: Assertion

This causes the assertion to evaluate the type of the value, rather than the actual input value. The type will always be a lowercase string. It is a smart typeof that can tell things like 'promise' and 'regexp' that might otherewise evaluate to plain old object.

```
this.assert(5).type.equals('number');
```

## AssertionContext

This is the context that each set of next callbacks within a Scenario operate with as the "this" value. It gives you all the handy methods and properties that you need.

### Methods

[ working on it ]

#### assert(value: any): Assertion

Creates an assertion with the input value.

```
this.assert(await this.select('article.topStory h1'))
```

#### comment(message: string)

Add a comment to the Scenario output.

#### evaluate(callback: Function): Promise<any>

Passes this function off to the underlying response to run it in the context of that type. 

For example, if this is a browser type the callback will be handed off to Puppeteer and actually run within the browser. Like this...

```
const url = await this.evaluate(() => {
  return window.location.href;
});
```

As you can see, you can not only execute the code in that browser's context, but you can reach in and return values from it.

If this is a Cheerio html type scenario, you can execute against the raw Cheerio jQuery-like DOM parser.

```
const loginText = await this.evaluate(($) => {
  return $('a.login').first('span').text();
});
```

For a REST API response this is less useful perhaps, but you are passed the JSON response to do something with like this.

```
const loginText = await this.evaluate((json) => {
  return json.meta.totalResults;
});
```

In theory, with any of these types, you could also manipulate the response with this method.

#### pause(milleseconds: number): Promise<void>

Delay the execution by this much

```
await this.pause(1000);
```

#### select(path: string): Promise<DOMElement | CSSRule | Value | null>

Select the element or value at the given path. What this actually does varies by the type of scenario. 

Browser and Html tests both return DOMElement. Stylesheet requests return CSSRule and JSON/REST scenarios return a Value.

Note it returns only one element. If multiple match the path then it returns the first. If none match then it returns null.

```
const firstArticle = await this.select('section.topStories article');
```

#### selectAll(path: string): Promise<DOMElement[] | CSSRule[] | Value[] || []>

Select the elements or values at the given path. What this actually does varies by the type of scenario. Browser and Html tests both return DOMElement. Stylesheet requests return CSSRule and JSON/REST scenarios return a Value.

This always returns an array. It will be an empty array if nothing matched. The array elements themselves will be the same object types that you'd have gotten from `.select(path)`.

```
const articles = await this.selectAll('section.topStories article');
```

### Properties 

#### browser: Browser | null

The Browser object that we can use the interact with Pupetter or null if this is not a browser type Scenario.

#### page: Puppeteer.Page | null

The Page object from the Puppeteer browser instance. This will be null if not a browser scenario or for some reason Puppeteer fails to load it. You can use this to interact directly with Puppeteer (see the Puppeteer API for that) it is very useful for things that Flagpole does not directly implement through sugar syntax wrappers.

#### response: iResponse

The response from the request. This will vary based on the type of Scenario, but some underlying properties are constant in the interface. 

This is often used to pull something like the load time, HTTP Status, headers, mime type, raw response body, etc.

#### result: any

If you chain multiple next callbacks together in a Scenario, you can return a value from one and then pull it into the following. To do this you will use `this.result` to grab that previously returned value. You may find that it is wrapped in a promise and then do `await this.result` to handle that.

#### scenario: Scenario

A reference to the calling Scenario.

#### suite: Suite

The parent Suite of this Scenario.

## CSSRule

This object contains declarations for a given CSS selector. You would get this within the context of a Stylesheet scenario. This would come from a this.select('#myElement') type selector from the AssertionContext.

### Methods

#### hasProperty(key: string): Promise<boolean> 

Test whether this rule has the given CSS property.

```
const rule = await this.select('body');
this.assert(await rule.hasProperty('background')).equals(true);
```

#### getProperty(key: string): Promise<Value | null> 

Get the matching property for this CSS Rule. Returns null if the property does not exist.

```
const rule = await this.select('body');
this.assert(await rule.getProperty('background')).equals('#ffffff');
```

### Properties 

#### $: any (readonly)

This is a quick way to get the underlying value within this wrapper object.

#### path: string (readonly)

The selector path that was used to query this rule.

#### name: string (readonly)

Get a friendly name for this Value, which may be something like the selector if it's an element or something similar that is hopefully human readable. This is mainly used when you do not provide specific assertion messages so that Flagpole can create meaningful default messages.


## DOMElement

This object contains elements within the DOM for Puppeteer browser scenarios or Cheerio HTML scenarios. You typically get this element by way of this.select('css selector path') from the AssertionContext.

### Methods

[ working on it ]

### Properties 

#### $: any (readonly)

This is a quick way to get the underlying value within this wrapper object. So that will typically be either an ElementHandle if a browser test or a Cheerio object if an html test.

#### name: string (readonly)

Get a friendly name for this DOMElement, which may be something like the selector if it's an element or something similar that is hopefully human readable. This is mainly used when you do not provide specific assertion messages so that Flagpole can create meaningful default messages.

#### path: string (readonly)

The selector requested to query this DOMElement.

## Scenario

A scenario is a collection of tests. It is a child of a Suite.

### Methods

[ working on it ]

### Properties 

#### executionDuration: number | null

The total time between when the Scenario was started executing and when it finished running. Null if it has not yet completed.

#### responseDuration: number | null

The total time between when the Scenario's request went out and when the response back back. Null if it the request has not yet returned a response.

#### responseType: ResponseType (readonly, enum)

The type of Scenario this is, the type of request we'll make and the response we'll expect back.

*Possible Values: html, json, image, stylesheet, script, video, audio, resource, browser, extjs*

#### title: string

Title of the Scenario as it will be printed on reports.

#### totalDuration: number | null

The total time between when the Scenario was initialized and when it finished running. Null if it has not yet completed.

## Suite

A Suite is essentially a collection of test Scenarios. You will be able to choose which suite or suites you want to run, so it's important to think how you want to group them.

### Methods

#### after(callback: Function): Suite

Hit this callback after all Scenarios finish executing.

`suite.after(() => { })`

#### afterEach(callback: Function): Suite

Hit this callback after each Scenario finishes executing.

`suite.afterEach(() => { })`

#### base(parms: string | {}): Suite

Set the base URL that all Scenarios in this Suite will use as its starting point.

This can be just a string:

`suite.base('https://www.google.com/')`

Or it can be an object with environment as its key and the domain as its value.

```
suite.base({
  prod: 'https://www.google.com/',
  stag: 'http://www.google.internal/'
  dev: 'http://www.google.local/'
})
```

#### before(callback: Function): Suite

Hit this callback before the first Scenario starts executing.

`suite.before(() => { })`

#### beforeEach(callback: Function): Suite

Hit this callback before each Scenario starts executing.

`suite.beforeEach(() => { })`

#### browser(title: string, opts: any = {}): Scenario

Creates a new Scenario of the Browser request type. This will run a version of Chrominium with Puppeteer. 

`suite.browser('User Sign Up Work Flow', { headless: true, width: 1280, height: 800 })`

#### buildUrl(path: string): string

Creates a fully qualified URL based on the input string. This will be relative to the Suite's base.

`suite.buildUrl('/index.html')`

#### catch(callback: Function): Suite

Hit this callback after the Suite completes if there is an error or failure in any Scenario.

`suite.catch(() => { })`

#### execute(): Suite

If this string was told to wait() to execute, this will kick it off. This method will trigger the execute to then be called on each Scenario in the Suite.

`suite.execute()`

#### extjs(title: string, opts: any = {}): Scenario

Creates a new Scenario of the ExtJS request type. This will use Puppeteer just like the browser variety. The only difference is that it has Ext specific select methods and other helper methods to dig into this framework's custom internals.

`suite.extjs('User Sign Up Work Flow', { headless: true, width: 1280, height: 800 })`

#### failed(): boolean

Did this Suite (or any of its Scenarios) fail? If the Suite is not yet completed (or hasn't started yet) this will be false, unless any Scenario has already failed.

`suite.failed()`

#### finally(callback: Function): Suite

Hit this callback after all Scenarios finish executing and after the Suite has been marked completed. This is the final step.

`suite.finally(() => { })`

#### html(title: string, opts: any = {}): Scenario

Creates a new Scenario of the HTML/DOM Only request type. This will use Cheerio to grab the HTML and load it into a jQuery-like DOM that we can test against. We can fake a browser here, allowing form completion, clicks, etc. However, it just is not a full browser so does not have JavaScript and won't work on SPAs, unless they have server side rendering as well.

`suite.html('Homepage Test')`

#### image(title: string, opts: any = {}): Scenario

Creates a new Scenario of the Image request type. This will use probe-image-size library to grab only the first few bytes of the image (not download the entire thing). This allows us to quickly test the basic properties.

`suite.image('Make sure image loads and is correct width')`

#### json(title: string, opts: any = {}): Scenario

Creates a new Scenario of the JSON/API End Point request type.

`suite.json('Articles API Test')`

#### next(callback: Function): Suite

Hit this callback after all Scenarios finish executing, but before Suite has been marked as completed. There can be multiple nexts.

`suite.next(() => { })`

#### passed(): boolean

Did this Suite (and all of its Scenarios) complete and all were passing?

`suite.passed()`

#### print(exitAfterPrint: boolean = true): void

Prints the results from the test execution to the console. This is often run inside the finally callback. If you leave the default argument as true, the process will terminate after it prints. So be sure to set that to false if you don't want it to do so.

`suite.finally(suite => suite.print(false))`

#### resource(title: string, opts: any = {}): Scenario

Creates a new Scenario of the Generic Resource request type. This is any other random type of file. You can test the file size, mime type, content, HTTP status, etc.

`suite.resource('Make sure this file loads')`

#### script(title: string, opts: any = {}): Scenario

Creates a new Scenario of the Script request type. It doesn't currently do anything more than load it. You can test the file size, mime type, HTTP Status, and such... so it may have some use but does not currently validate the JS.

`suite.script('Make sure JS file loads')`

#### subscribe(callback: Function): void

Adds this callback to a PubSub subscription to get notified on any updates with the execute of thie Suite.

This will probably return a handle to be able to unsubscribe later, but it doesn't return anything yet.

`suite.callback((suite: Suite, status: SuiteStatusEvent) => {  });`

#### success(callback: Function): Suite

Hit this callback after all Scenarios finish executing if all Scenarios passed. This happens following after and next, but before finally.

`suite.success(() => { })`

#### verifySslCert(verify: boolean): Suite

Tells the request not to worry about verifying any SSL certs for HTTPS requests. This is helpful for local environments that may not have a valid cert. This value is passed on to any Scenarios created in this Suite, so you don't have to set it each time.

`suite.verifySslCert(false)`

#### video(title: string, opts: any = {}): Suite

Creates a new Scenario of the Video request type.

`suite.video('Make sure video loads')`

#### wait(verify: boolean = true): Suite

Tells this suite not to execute right away. Will not execute any scenarios until .execute() is called. This wait value gets passed to any Scenarios created under this Suite, so that you don't have to set it each time.

`suite.wait()`

### Properties

#### baseUrl: string

The base URL tha tis being used to execute Scenarios in this Suite. It will come from the settings in the .base() method and what environment is selected.

#### executionDuration: number | null

The amount of time, in milliseconds, between when the first Scenario in the Suite started to execute and when the last one was completed.

#### title: string

The title of this suite, which is specified in the constructor.

#### totalDuration: number | null

The total amount of time, in milliseconds, between when the Suite was initialized and when it was completed.

## Value

This object is the result of queried properties on a DOMElement, CSSRule, or from this.select('property') on a JSON/REST or Image type scenario. It is a wrapper of the actual underlying value that lets you do some nice things.

### Methods

#### getProperty(key: string): Promise<any>

Get the property of this input value with the key. If there is no such property then it will return null. This is an async method.

#### hasProperty(key: string): Promise<boolean>

If this element is an object of some sort, does it have the property matching key? Note this is an async function.

#### isNullOrUndefined(): boolean

Self explanatory.

#### isUndefined(): boolean

Self explanatory.

#### isNull(): boolean

Is this input value literally null.

#### isPromise(): boolean

Self explanatory.

#### isArray(): boolean

Self explanatory.

#### isCookie(): boolean

Self explanatory.

#### isRegularExpression(): boolean

Is the input value a regular expression pattern (RegExp type).

#### isNaN(): boolean

Is this input value literally the JavaScript value of NaN.

#### isNumber(): boolean

Is this input value of type number? NaN will return false.

#### isNumeric(): boolean

Is the input value numeric, even if it is a string or something else for its actual type.

#### isObject(): boolean

Self explanatory.

#### isString(): boolean

Self explanatory.

#### toArray(): any[]

Converts the input value into an array. If it's not already an array then it just wraps it in an array.

#### toString(): string

Casts the input value as a string. 

#### toType(): string

Grabs the type of the input value. It will be all lowercase and is a deep type look up, beyond a normal typeof.

### Properties 

#### $: any (readonly)

This is a quick way to get the underlying value within this wrapper object.

#### length: number (readonly)

Get the length of the input value. This could be the number of characters in a string-like value or the number of elements if it's an array.

#### name: string (readonly)

Get a friendly name for this Value, which may be something like the selector if it's an element or something similar that is hopefully human readable. This is mainly used when you do not provide specific assertion messages so that Flagpole can create meaningful default messages.



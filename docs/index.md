# What is Flagpole?

*"Let me run it up the flagpole first"*

Running something up the flagpole means you check on it first to see if it's good before going forward. And that's exactly what this framework is about, so we like the analogy. 

Flagpole is a flexible framework that can support a number of different types of testing:

* Full browser testing with Puppeteer
* Super-fast HTML DOM testing with Cheerio (jQuery for Node)
* REST API/JSON End Points
* Lightweight image tester that can verify the dimensions, mime and file size without downloading the whole thing
* Stylesheets including basic CSS validation
* Basic validation for other resources like JavaScript

Flagpole is designed to be simple so that the most junior engineer or QA analyst can pick it up within hours.

Flagpole is designed for portability, so that you can run it locally within your repository from a githook, in the cloud when something is deployed, as a scheduled job, or manually any time you want.

Flagpole has a rich CLI that can be used to list tests, run tests, create new suites or scenarios, etc.

# Getting Started

First thing we need to do is install Flagpole with npm. Go into the root of your project and run this:

```bash
npm i flagpole -g
npm i flagpole --save-dev
```

The above command installs it both locally (within the project) and globally. This is a little annoying that we have to do both. But we do. Globally is so that the command "flagpole" will run. The second one is so that your test suites can find it.

If you want to also use Puppeteer in your project install it as well, as a dev dependency.

```bash
npm i puppeteer --save-dev
```

You should be able to run the flagpole command now, which will give you instructions on how to use the CLI.

```bash
flagpole
```

Pretty colors, eh?

Now let's initialize our project

```bash
flagpole init
```

Once you answer those questions, you should have a flagpole.json file. Now we need to create our first test scenario.


```bash
flagpole add suite
```

Answer those questions and it will set up your first test file. Now let's make sure. If we run this command you should see it listed.

```bash
flagpole list
```

We should be able to run this very basic test with:

```bash
flagpole run
```

Sweet! How about we actually do something with the test now and run it. So open that test file that was generated by our "add suite" command earlier and add this into the next callback:

```typescript
this.assert('HTTP Status equals 200', response.status().equals(200);
```

Now run the flagpole run command again...

```bash
flagpole run
```

And if we did everything right, then you should see something like:

```text

 ================================================== 
                    HELLO WORLD                    
 ================================================== 
 » Base URL: http://www.flosports.tv 
 » Environment: dev 
 » Took 1383ms
 
 » Passed? Yes
 
 Just getting a test to run 
   ✔  Loaded HTML Page / 
   ✔  HTTP Status equals 200 
   »  Took 1382ms

```

Documentation is below, but also see the [examples folder in the repo](https://github.com/flocasts/flagpole/tree/master/example) and there will be blog posts coming up.

# Flagpole 2.0 CLI

## Commands

### about

Gives some information about Flagpole and its contributors.

```bash
flagpole about
```

### add env

Allows you to add a new environment. Environments are things like dev, staging, and prod. Each environment in a suite can have its own domain base, which allows you to use the same tests across environments easily.

```bash
flagpole add env
```

### add scenario

Adds a new scenario to a suite. If you have no suites set up yet, this will fail. If you have multiple suites, it will ask you which on you want to add the new scenario to.

This method will go into the suite file and add the code. Of course you can add this code manually, but this just gives you a template to start with.

```bash
flagpole add scenario
```

### add suite

Adds a new suite to the project. This will create the suite file and add in the base code. Of course you can add this all manually, but this just gives you a template to start with.

```bash
flagpole add suite
```

### deploy

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole deploy
```

### import suite

If you created or dropped some .js suite files into the tests folder without going through the CLI, this allows you to officially import them into the project.

```bash
flagpole import suite
```

### init

Initializes flagpole to set it up in the current project folder.

```bash
flagpole init
```

### list

Lists out all of the suites available in this project.

```bash
flagpole list
```

### login

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole login
```

### logout

In the future there will be a web based control panel where you can view, manage and run your tests in the cloud. This feature is not available in 2.0 but maybe in 3.0!

```bash
flagpole logout
```

### pack

Puts your test suites and project files into a zip file so that they can be copied to something else.

```bash
flagpole pack
```

### rm env

Allows you to remove an environment from the project. This will remove it from the config, but will not modify your existing suite that reference it.

```bash
flagpole rm env
```

### rm suite

Allows you to remove a suite from the project. This will remove it from the config and delete the file

```bash
flagpole rm suite
```

### run

Runs your test suites. With no switches like this, it will run every one of the tests. See the -s switch about selecting which suite(s) specifically to run.

```bash
flagpole run
```

## Switches

### -c pathToConfig

By default Flagpole looks for flagpole.json file in the current folder as the project config. But you can use this switch to tell it to look elsewhere.

```bash
flagpole run -c /path/to/flagpole.json
```

### -e environmentName

Specifies the environment name, which will be the context that the tests execute with.

```bash
flagpole run -e staging
```

### -h

Hides the ASCII banner graphic.

```bash
flagpole run -h
```

### -l

There are some decorative florishes with the Flagpole output. Extra line breaks, horizontal rules, etc. They make it more readable. But perhaps you're trying to send the output to a log and you don't want that stuff. 

This "log" switch makes it only do the content lines and does one per line.

```bash
flagpole run -l
```

### -o outputType

Specifies that type of output you want Flagpole to create. The defualt is this pretty colored console ASCII text. But there are other options:

* browser - Formats it into HTML and opens it in your default web browser after
* console - Default
* csv - Comma separated
* html - Outputs HTML to the console
* json - JSON formatted 
* psv - Pipe separated
* text - Same as default but without the ASCII colors
* tsv - Tab separated

```bash
flagpole run -o browser
```

### -q 

Quiet mode. Silences all Flagpole command line output. This is useful when you don't want to capture what it has to say, you just want to know if it passed or failed. Which a script running this could get from the exit code of 0 or 1.

```bash
flagpole run -q
```

### -s suiteName

Specifies a certain suite or suites to run.

```bash
flagpole run -s smoke
```

You can list out multiple suite, space separated.

```bash
flagpole run -s smoke api e2e
```

### -v

Prints out simply what version of Flagpole CLI is installed.

```bash
flagpole -v
```


# Flagpole 2.0 Developer Docs

Here are the detailed documentation of the different methods you'll interact with in Flagpole.

[ under construction ]

## Assertions

Create an assertion within your scenario's "next" blocks like this:

```
this.assert(myValue)
```

You can also specify a message first, to override Flagpole's attempt at creating a default assertion method. That way it is really descriptive of what that assertion checks for.

```
this.assert('Make sure my value is a number', myValue)
```

This alone does nothing, since it just creates the assertion object with the value you want to assert against. But it hasn't actually asserted anything. So use one of the methods below.

### Methods

#### between

Works for numbers, but also casts strings to numbers for the compare. Tests if this value is between the minimum and maximum.

```
this.assert(myValue).between(0, 10);
```

#### contains

Tests whether the input value contains the argument. This works for strings, arrays, and even for objects. If it's an object, it checks if a property exists with that value.

```
this.assert('foobar').contains('foo');
```

#### endsWith

Tests whether the input value ends with the argument. Also works with arrays, testing whether the argument is the last value of the array.

```
this.assert('foobar').endsWith('bar');
```

#### equals

This be used with any types of values. It uses a rough (double equals) equality versus the exactly method that uses a precise (triple equals) equality.

```
this.assert(myValue).equals(5);
```

#### every

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that every one is true.

```
this.assert(['eminem', 'dre', 'ice cube']).every((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### exactly

This asserts an exact match with precise (triple equals) equality.

```
this.assert(myValue).exactly(5);
```

#### exists

Tests whether the input value is not null or undefined. This works well for selecting a DOM Element and then testing if it actually existed (since it returns null if not).

```
this.assert(await this.select('article')).exists();
```

#### greaterThan

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThan(5);
```

#### greaterThanOrEquals

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).greaterThanOrEquals(5);
```

#### in

Tests whether the input value is in the array of possible values.

```
this.assert('2pac').in(['2pac', 'biggie', 'daz']);
```

#### includes

Tests whether the input array includes the argument.

```
this.assert(['2pac', 'biggie', 'daz']).includes('2pac');
```

#### lessThan

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThan(5);
```

#### lessThanOrEquals

Works for numbers, but also casts strings to numbers for the compare.

```
this.assert(myValue).lessThanOrEquals(5);
```

#### like

Like is a more fuzzy match. It ignores type differences and also trims whitespace and compares strings all lowercase. So it indicates the values are similar, but not necessarily equal.

```
this.assert(myValue).like('FooBar');
```

#### matches

Regular express compare of strings.

```
this.assert(myValue).matches(/^[a-z0-9]{3,32}$/i);
```

#### none

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that none are true.

```
this.assert(['2pac', 'biggie', 'daz']).none((rapper) => {
  return rapper == 'snoop';
})
```

#### rejects

Tests whether the input promise rejects.

```
await this.assert(myPromise).rejects();
```

#### resolves

Tests whether the input promise resolves.

```
await this.assert(myPromise).resolves();
```

#### some

Loops throught the input value, which should be an array, and checks them against the callback function to be sure that at least one is true.

```
this.assert(['dre', 'snoop', '2pac']).some((rapper) => {
  return rapper.indexOf('e') >= 0;
})
```

#### startsWith

Tests whether the input value starts with the argument. Also works with arrays, testing whether the argument is the first value of the array.

```
this.assert(['foo', 'bar']).startsWith('foo');
```

### Properties

In addition to the methods to make the assertions, you can change them by chaining these properties.

#### length

This causes the assertion to evaluate the length of the input value, rather than the actual value. This works for anything that supports length including strings and arrays. For other things it will cast the input to a string and evaluate it.

```
this.assert('foobar').length.equals(6);
```

#### not

Flips the assertion to be the negative of itself.

```
this.assert(5).not.equals(6);
```

#### optional

This makes the assertion consider optional, meaning its failure won't cause the entire scenario to fail. If it passes, it will be listed as a pass. If it fails, it will be shown as failing in a special type of comment. That way you can see it, but not hold up the deploy because of it.

```
this.assert(5).optional.equals(6);
```

#### type

This causes the assertion to evaluate the type of the value, rather than the actual input value. The type will always be a lowercase string. It is a smart typeof that can tell things like 'promise' and 'regexp' that might otherewise evaluate to plain old object.

```
this.assert(5).type.equals('number');
```



